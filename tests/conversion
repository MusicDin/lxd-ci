#!/bin/bash
set -eu

# Source helper functions.
# shellcheck disable=SC1091
. ./bin/helpers

# XXX: virt-v2v is recent enough in 24.04 onward. For older releases,
# virt-v2v is not installed, and the conversion test is skipped.
# shellcheck disable=SC1091
. /etc/os-release
if dpkg --compare-versions "${VERSION_ID}" ge 24.04; then
      install_deps jq unzip virt-v2v
else
      install_deps jq unzip
fi

# Install LXD
install_lxd

set -x

if ! command -v go; then
    # Install go from Snap.
    snap install go --classic
fi

export PATH="${HOME}/go/bin:${PATH}"

# Install latest lxd-migrate binary tool.
CGO_ENABLED=0 go install github.com/canonical/lxd/lxd-migrate@latest
# Make it smaller
strip --strip-all "$(command -v lxd-migrate)"

# Configure LXD
lxd init --auto --network-address "[::]" --network-port "8443"

# Unblock images remote.
sed -i '/images\.lxd\.canonical\.com/d' /etc/hosts
systemctl restart systemd-resolved.service

checkIPAddresses() {
    instName=$1

    address="$(lxc query "/1.0/instances/${instName}/state" | jq -r '.network | .[].addresses | .[] | select(.scope == "global") | .address')"

    if [ -z "${address}" ]; then
        echo "===> FAIL: No network interface: ${instName}"

        # Show the network state.
        echo "===> DEBUG: network state: ${instName}"
        lxc info "${instName}"
        return 1
    fi

    fail=0

    # IPv4 address
    if echo "${address}" | grep -qF "."; then
        echo "===> PASS: IPv4 address: ${instName}"
    else
        echo "===> FAIL: IPv4 address: ${instName}"
        fail=1
    fi

    # IPv6 address
    if echo "${address}" | grep -qF ":"; then
        echo "===> PASS: IPv6 address: ${instName}"
    else
        echo "===> FAIL: IPv6 address: ${instName}"
        fail=1
    fi

    return "${fail}"
}

checkDNS() {
    instName=$1

    # Test lxd-agent and DNS resolution.
    if lxc exec "${instName}" -- nslookup canonical.com >/dev/null 2>&1; then
        echo "===> PASS: DNS resolution: ${instName}"
        return 0
    fi

    if lxc exec "${instName}" -- getent hosts canonical.com >/dev/null 2>&1; then
        echo "===> PASS: DNS resolution: ${instName}"
        return 0
    fi

    echo "===> FAIL: DNS resolution: ${instName}"
    return 1
}

testImportedInstance() {
    instName=$1

    # Start the instance.
    echo "Starting instance ${instName}..."
    lxc start "${instName}"

    # Wait for the instance to be ready and ensure it has global IP addresses.
    echo "Waiting instance ${instName} to start..."
    waitInstanceReady "${instName}"
    for _ in $(seq 10); do
        sleep 1
        [ "$(lxc query "/1.0/instances/${instName}/state" | jq -r '.network | .[].addresses | .[] | select(.scope == "global") | .address' | wc -l)" -ge 2 ] && break
    done

    # Print the instances.
    lxc list

    echo "Check network connectivity of instance ${instName}..."
    checkIPAddresses "${instName}"

    echo "Check DNS resolution of instance ${instName}..."
    checkDNS "${instName}"

    # Cleanup.
    lxc delete -f "${instName}"
}

# conversion_vm creates a new LXD virtual machine from the image on the given path.
# A dedicated storage pool of the given type will be created for a new virtual machine.
#
# Input arguments:
# 1: Name of new virtual machine.
# 2: Type of the storage pool.
# 3: Path to the image.
# 4: Enable secureboot (yes/no).
# 5: Conversion options (defaults to "format").
conversion_vm() {
    conversion vm "$1" "$2" "$3" "$4" "${5:-format}"
}

# conversion_container creates a new LXD container from the filesystem of the existing container.
#
# Input arguments:
# 1: Name of the existing container.
conversion_container() {
    conversion container "$1" "" "/" "no" ""
}

# conversion runs lxd-migrate for the given image path. For virtual machine, lxd-migrate is
# executed on the localhost. For container, lxd-migrate will be installed and executed from
# an existing container.
conversion() {
    instType=$1
    instName=$2
    poolType=$3
    imgPath=$4
    uefi_sb=$5
    conversionOptions=$6

    if [ "${instType}" = "vm" ]; then
        echo "==> TEST: Conversion: Import virtual-machine '${instName}' on '${poolType}' storage pool"

        instName="vm-${instName}-${poolType}"
        poolName="pool-${instName}-${poolType}"
        hostAddr="127.0.0.1"
        instTypeCode="2" # VM in migration questioneer.

        lxdMigrateCmd="lxd-migrate --conversion=${conversionOptions}"

        # Create storage pool.
        if [ "$poolType" = "ceph" ] || [ "$poolType" = "dir" ]; then
            lxc storage create "${poolName}" "${poolType}"
        else
            lxc storage create "${poolName}" "${poolType}" size=11GiB
        fi

    elif [ "${instType}" = "container" ]; then
        echo "==> TEST: Conversion: Import container '${instName}'"

        poolName=""
        hostAddr=$(lxc network get lxdbr0 ipv4.address | cut -d/ -f1)
        instTypeCode="1" # Container.

        lxdMigrateCmd="lxc exec ${instName} -- /root/go/bin/lxd-migrate"

        # Install rsync and lxd-migrate.
        lxc exec "${instName}" -- apt-get update
        lxc exec "${instName}" -- apt-get install --no-install-recommends -y rsync file
        lxc file push --create-dirs --mode 0755 --quiet "$(command -v lxd-migrate)" "${instName}"/root/go/bin/lxd-migrate

        # Set instName to the name of the new container that will be created
        # from the existing one.
        instName="${instName}-migration"
    else
        echo "Invalid instance type '${instType}'. Valid types are 'container' and 'vm'."
        return 1
    fi

    # Generate trust token for conversion.
    token="$(lxc config trust add --quiet --name migrate)"
    if [ -z "${token}" ]; then
        echo "Failed to generate LXD trust token!"
        return 1
    fi

    # Migration questions.
    {
        if [ "${instType}" = "vm" ]; then
            echo "n"           # Do not use local unix socket.
        fi

        echo "${hostAddr}"     # Address of the target LXD server.
        sleep 1
        echo "y"               # Confirm the local LXD server is the target.
        sleep 1
        echo "1"               # Use a certificate token.
        echo "${token}"        # Token.
        echo "${instTypeCode}" # Instance type (1 == container, 2 == virtual-machine).

        if [ "$(lxc project ls -f csv | wc -l)" -gt 1 ]; then
            echo "default"     # Project name (required if there is more then 1 project)
        fi

        echo "${instName}"     # Instance name.
        echo "${imgPath}"      # Local image path (or filesystem path in case of container).
        echo "${uefi_sb}"      # Enable UEFI secure boot.

        # Configure storage pool.
        if [ "${poolName}" != "" ]; then
            echo "4"           # Change storage pool settings.
            echo "${poolName}" # Pool name.
            echo "yes"         # Configure pool size?
            echo "10GiB"       # Pool size.
        fi

        # Begin the migration with the above configuration
        sleep 1
        echo "1"
    } | $lxdMigrateCmd

    testImportedInstance "${instName}"

    if [ "${poolName}" != "" ]; then
        lxc storage delete "${poolName}"
    fi
}

tmpdir="$(mktemp -d)"

# Test VM conversion using non-raw disk formats only if server supports
# conversion API extension.
if hasNeededAPIExtension instance_import_conversion; then
    # Test QCOW2 images.
    IMAGE_PATH="./image-tmp"
    mkdir -p "${IMAGE_PATH}"

    # Test virtio conversion if virt-v2v-in-place is installed.
    if ! command -v virt-v2v-in-place > /dev/null; then
        echo "===> SKIP: The virt-v2v-in-place is not installed"
    else
        virt-v2v-in-place --version

        # Create new instance.
        lxc launch images:centos/9-Stream v1 --vm --config limits.cpu=2 --config limits.memory=2GiB
        waitInstanceBooted v1
        sleep 1

        # Remove LXD dracut configuration to allow removing the virtio_scsi module.
        # Afterwards, rebuild the initramfs image and stop the instance.
        lxc exec v1 -- rm /etc/dracut.conf.d/lxd.conf
        lxc exec v1 -- dracut --force --omit-drivers virtio_scsi

        # XXX: Disable SELinux before exporting the instance, as it will block lxd-agent
        # when re-imported.
        if lxc exec v1 -- test -e /etc/selinux/config; then
            lxc exec v1 -- sed -i "s/SELINUX=enforcing/SELINUX=disabled/" /etc/selinux/config
        fi

        # Export instance and extract raw image.
        lxc stop v1
        lxc export v1 --compression=none --quiet - | tar -xf - -C "${IMAGE_PATH}" "backup/virtual-machine.img"

        echo ">>> NOTE: Image exported to ${IMAGE_PATH}/backup/virtual-machine.img"


        lxc launch ubuntu:24.04 v2v \
            --config security.privileged=true \
            --config limits.memory=4GiB \
            --config limits.cpu=4


        waitInstanceBooted v2v

        lxc exec v2v -- sudo apt-get update
        lxc exec v2v -- sudo apt-get install -y virt-v2v
        lxc push --create-dirs --mode 0755 "${IMAGE_PATH}/backup/virtual-machine.img" v2v/root/virtual-machine.img
        lxc exec v2v -- virt-v2v-in-place -x -v -i disk -if raw --block-driver virtio-scsi virtual-machine.img





        # Ensure instance does not boot without virtio_scsi drivers.
        # lxc start v1
        # ! waitInstanceReady v1 || { echo "Instance booted without SCSI drivers!"; false; }
        # lxc delete -f v1

        # chmod -R 777 "${IMAGE_PATH}"

        # echo "==> CONVERT: Manual conversion"
        # sudo virt-v2v-in-place -x -v -i disk -if raw --block-driver virtio-scsi "${IMAGE_PATH}/backup/virtual-machine.img"


        # echo "==> CONVERT: LXD conversion"
        # Ensure that virtio conversion adds the needed virtio_scsi module back into the initramfs.
        # conversion_vm centos-missing-driver zfs "${IMAGE_PATH}/backup/virtual-machine.img" "no" "virtio"
        # lxc delete -f v1
    fi

    # Cleanup.
    # rm -rf "${tmpdir}"
    # lxc config unset storage.backups_volume
    # lxc storage volume delete backups-pool backups-vol
    # lxc storage delete backups-pool
else
    echo "===> SKIP: VM image conversion skipped. Server does not support API extenison 'instance_import_conversion'"
fi

# shellcheck disable=SC2034
FAIL=0
